<!DOCTYPE html>
<html>
  <head>
  <meta charset='UTF-8'>
  <title>CoffeeScript API Documentation</title>
  <link rel='stylesheet' href='..&#47;assets/codo.css' type='text/css'>
  <script src='..&#47;assets/codo.js'></script>
  <script src='..&#47;assets/search_data.js'></script>
</head>
  <body>
    <div id='base' data-path='..&#47;'></div>
<div id='header'>
  <div id='menu'>
    <a href='..&#47;README.md.html' title='Livecodelab'>Livecodelab</a>
    &raquo;
    <a href='..&#47;class_index.html' title='Index'>Index</a>
    &raquo;
    <span class='title'>LexerState</span>
    <nav>
      <ul>
        <li class='noframes'>
          (<a class='noframes' href='#'>no frames</a>)
        </li>
      </ul>
    </nav>
    <div id='search'>
      <a id='class_list_link' href='..&#47;class_list.html'>Classes</a>
      <a id='file_list_link' href='..&#47;file_list.html'>Files</a>
      <a id='method_list_link' href='..&#47;method_list.html'>Methods</a>
      <a id='extra_list_link' href='..&#47;extra_list.html'>Extras</a>
    </div>
  </div>
  <iframe id='search_frame'></iframe>
  <div id='fuzzySearch'>
    <input type='text'>
    <ol></ol>
  </div>
  <div id='help'>
    <p>
      Quickly fuzzy find classes, mixins, methods, file:
    </p>
    <ul>
      <li>
        <span>Ctrl-T</span>
        Open fuzzy finder dialog
      </li>
    </ul>
    <p>
      In frame mode you can toggle the list naviation frame on the left side:
    </p>
    <ul>
      <li>
        <span>Ctrl-L</span>
        Toggle list view
      </li>
    </ul>
    <p>
      You can focus a list in frame mode or toggle a tab in frameless mode:
    </p>
    <ul>
      <li>
        <span>Ctrl-C</span>
        Class list
      </li>
      <li>
        <span>Ctrl-I</span>
        Mixin list
      </li>
      <li>
        <span>Ctrl-F</span>
        File list
      </li>
      <li>
        <span>Ctrl-M</span>
        Method list
      </li>
      <li>
        <span>Ctrl-E</span>
        Extras list
      </li>
    </ul>
    <p>
      You can focus and blur the search input:
    </p>
    <ul>
      <li>
        <span>Ctrl-S</span>
        Focus search input
      </li>
      <li>
        <span>Esc</span>
        Blur search input
      </li>
    </ul>
    <p>
      In frameless mode you can close the list tab:
    </p>
    <ul>
      <li>
        <span>Esc</span>
        Close list tab
      </li>
    </ul>
  </div>
</div>
    <div id='content'>
      <h1>
        Class:
        LexerState
      </h1>
      <table class='box'>
        <tr>
          <td>Defined in:</td>
          <td>coffee&#47;autocoder&#47;lexer.coffee</td>
        </tr>
      </table>
      <h2>Overview</h2>
      <div class='docstring'>
  <p>Lexer is a variation/port of:</p><p>McLexer: A lexical analysis system/library for JavaScript.
Author:  Matthew Might
Site:    <a href="http://matt.might.net/">http://matt.might.net/</a>
         <a href="http://www.ucombinator.com/">http://www.ucombinator.com/</a></p><p>McLexer associates rules with analysis states.</p><p>Each rule contains a regular expression to match, 
and action to execute upon finding a match.</p><p>When a state matches its rules against an input text, 
it chooses the rule with the longest match against the prefix 
of the input text.</p><p>A lexical state is a collection of rules.</p><p>It has three primary methods:</p><ul>
<li><p>lex(input) runs a continuation-based lexer on the input; lex invokes next once, and expects a continuation back; it then invokes the continuation and expects each continuation it invokes to return another continuation.  Once a continuation returns null; parsing is complete.     </p></li>
<li><p>findAndRunActionPairedToLongestAppliableRegex(input) runs a match against an input, fires the action. An action is a procedure that accepts the match data (an array), the remainder of the input, and the current state and returns a function that applies the rules again and finds and runs the next action. An action does not run the next one (that would be recursion). Rather, it returns a function to find and run the next one</p></li>
</ul><p>Why this &quot;step by step&quot; approach instead of a normal recursion? The advantage is
that you can stop the parsing and resume it any time you want. Suppose that
you have a huge program to parse. With recursion, once you start you can&#39;t
stop until the end (at least if you are using normal recursion as provided by
the language runtime. If you implement your own recursion using your own stack
then you could indeed pause/resume things). In a single-threaded language like
Javascript this results in everything else &quot;blocking&quot;. A &quot;continuations&quot; approach
lets you stop and resume the parsing more easily, since you lex the program step
by step in a manner that does not rely on the runtime stack. There is no recursion.</p>
</div>
<div class='tags'>
</div>
      <h2>Instance Method Summary</h2>
      <ul class='summary'>
  <li>
    <span class='signature'>
      <a href='#addRule-instance'>
        - (void) <strong>addRule</strong>(regex, action)
      </a>
    </span>
    <span class='desc'>
      
    </span>
  </li>
  <li>
    <span class='signature'>
      <a href='#lex-instance'>
        - (void) <strong>lex</strong>(input)
      </a>
    </span>
    <span class='desc'>
      
    </span>
  </li>
  <li>
    <span class='signature'>
      <a href='#findAndRunActionPairedToLongestAppliableRegex-instance'>
        - (void) <strong>findAndRunActionPairedToLongestAppliableRegex</strong>(input)
      </a>
    </span>
    <span class='desc'>
      
    </span>
  </li>
  <li>
    <span class='signature'>
      <a href='#returnAFunctionThatAppliesRulesAndRunsActionFor-instance'>
        - (void) <strong>returnAFunctionThatAppliesRulesAndRunsActionFor</strong>(input)
      </a>
    </span>
    <span class='desc'>
      
    </span>
  </li>
</ul>
      <h2>Instance Method Details</h2>
      <div class='methods'>
  <div class='method_details'>
    <p class='signature' id='addRule-instance'>
      - (void) <strong>addRule</strong>(regex, action)
    </p>
    <div class='tags'>
</div>
  </div>
  <div class='method_details'>
    <p class='signature' id='lex-instance'>
      - (void) <strong>lex</strong>(input)
    </p>
    <div class='tags'>
</div>
  </div>
  <div class='method_details'>
    <p class='signature' id='findAndRunActionPairedToLongestAppliableRegex-instance'>
      - (void) <strong>findAndRunActionPairedToLongestAppliableRegex</strong>(input)
    </p>
    <div class='tags'>
</div>
  </div>
  <div class='method_details'>
    <p class='signature' id='returnAFunctionThatAppliesRulesAndRunsActionFor-instance'>
      - (void) <strong>returnAFunctionThatAppliesRulesAndRunsActionFor</strong>(input)
    </p>
    <div class='tags'>
</div>
  </div>
</div>
    </div>
    <div id='footer'>
  Generated on
  Fri Jan 18 2013 19:47:23 GMT+0000 (GMT)
  by
  <a href='https://github.com/netzpirat/codo' title='CoffeeScript API documentation generator'>Codo</a>
  v1.5.4
  (Node.js v0.8.12).
  &#10034;
  Press Ctrl-h to see the keyboard shortcuts
  &#10034;
  <a href='http://twitter.com/#!/netzpirat'>@netzpirat</a>
  &#10034;
  <a href='https://mksoft.ch'>mksoft.ch</a>
</div>
  </body>
</html>