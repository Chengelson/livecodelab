<!doctype html>

<!-- Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc) -->

<html>
<head>
  <title>CoffeeDoc | lexer.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" media="all" href="../../resources/base.css" />
</head>
<body>
  <header>
    <h1>lexer.coffee</h1>
  </header>
  <div class="container">
    <div class="sidebar column">
      
      <h4>Classes</h4>
      <ul class="classlist">
        
        <li><a href="#LexerState">LexerState</a></li>
        
        <li><a href="#LexerRule">LexerRule</a></li>
        
      </ul>
      
      
    </div>
    <div class="content column">
      
      <div id="module-docstring">
        <p>Lexer is a variation/port of:

</p>
<p>McLexer: A lexical analysis system/library for JavaScript.
Author:  Matthew Might
Site:    http://matt.might.net/
         http://www.ucombinator.com/

</p>
<p>McLexer associates rules with analysis states.

</p>
<p>Each rule contains a regular expression to match, 
and action to execute upon finding a match.

</p>
<p>When a state matches its rules against an input text, 
it chooses the rule with the longest match against the prefix 
of the input text.

</p>
<p>A lexical state is a collection of rules.

</p>
<p>It has three primary methods:

</p>
<ul>
<li><p>lex(input) runs a continuation-based lexer on the input;
lex invokes next once, and expects a continuation back;
it then invokes the continuation and expects each continuation
it invokes to return another continuation.  Once a continuation
returns null; parsing is complete.     </p>
</li>
<li><p>findAndRunActionPairedToLongestAppliableRegex(input) runs a match against an input,
fires the action.
An action is a procedure that accepts the match data (an array),
the remainder of the input, and the current state and returns a function that
applies the rules again and finds and runs the next action. An action does not run
the next one (that would be recursion). Rather, it returns a function to find and
run the next one</p>
</li>
</ul>
<p>Why this &quot;step by step&quot; approach instead of a normal recursion? The advantage is
that you can stop the parsing and resume it any time you want. Suppose that
you have a huge program to parse. With recursion, once you start you can&#39;t
stop until the end (at least if you are using normal recursion as provided by
the language runtime. If you implement your own recursion using your own stack
then you could indeed pause/resume things). In a single-threaded language like
Javascript this results in everything else &quot;blocking&quot;. A &quot;continuations&quot; approach
lets you stop and resume the parsing more easily, since you lex the program step
by step in a manner that does not rely on the runtime stack. There is no recursion.
</p>

      </div>
      
      
      <div id="classes">
        <h2>Classes</h2>
        
        <div class="class">
          <div class="header">
            <a id="LexerState"><h3>LexerState</h3></a>
            
          </div>
          <div class="class-content">
            
            <div class="methods">
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>addRule(regex, action)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>lex(input)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>findAndRunActionPairedToLongestAppliableRegex(input)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>returnAFunctionThatAppliesRulesAndRunsActionFor(input)</h4>
                  
                </div>
                
              </div>
              
              
            </div>
          </div>
        </div>
        
        <div class="class">
          <div class="header">
            <a id="LexerRule"><h3>LexerRule</h3></a>
            
          </div>
          <div class="class-content">
            
            <div class="methods">
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>constructor(@regex, @action)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>matches(s)</h4>
                  
                </div>
                
              </div>
              
              
            </div>
          </div>
        </div>
        
      </div>
      
      
    </div>
  </div>
</body>
</html>
